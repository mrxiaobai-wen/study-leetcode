package greedy_algorithm.medium;

/**
 * 991. 坏了的计算器
 * 在显示着数字的坏计算器上，我们可以执行以下两种操作：
 * <p>
 * 双倍（Double）：将显示屏上的数字乘 2；
 * 递减（Decrement）：将显示屏上的数字减 1 。
 * 最初，计算器显示数字 X。
 * <p>
 * 返回显示数字 Y 所需的最小操作数。
 * <p>
 * <p>
 * <p>
 * 示例 1：
 * <p>
 * 输入：X = 2, Y = 3
 * 输出：2
 * 解释：先进行双倍运算，然后再进行递减运算 {2 -> 4 -> 3}.
 * 示例 2：
 * <p>
 * 输入：X = 5, Y = 8
 * 输出：2
 * 解释：先递减，再双倍 {5 -> 4 -> 8}.
 * 示例 3：
 * <p>
 * 输入：X = 3, Y = 10
 * 输出：3
 * 解释：先双倍，然后递减，再双倍 {3 -> 6 -> 5 -> 10}.
 * 示例 4：
 * <p>
 * 输入：X = 1024, Y = 1
 * 输出：1023
 * 解释：执行递减运算 1023 次
 * <p>
 * <p>
 * 提示：
 * <p>
 * 1 <= X <= 10^9
 * 1 <= Y <= 10^9
 */
public class BrokenCalculator_991 {
    public int brokenCalc(int X, int Y) {
        return fun(X, Y);
    }

    /**
     * 参考代码：
     * </p>
     * 逆向思维
     * 除了对 X 执行乘 2 或 减 1 操作之外，我们也可以对 Y 执行除 2（当 Y 是偶数时）或者加 1 操作。
     * 这样做的动机是我们可以总是贪心地执行除 2 操作：
     * 当 Y 是偶数，如果先执行 2 次加法操作，再执行 1 次除法操作，我们可以通过先执行 1 次除法操作，再执行 1 次加法操作以使用更少的操作次数得到相同的结果 [(Y+2) / 2 vs Y/2 + 1]。
     * <p>
     * 当 Y 是奇数，如果先执行 3 次加法操作，再执行 1 次除法操作，我们可以将其替代为顺次执行加法、除法、加法操作以使用更少的操作次数得到相同的结果 [(Y+3) / 2 vs (Y+1) / 2 + 1]。
     * <p>
     * 算法
     * <p>
     * 当 Y 大于 X 时，如果它是奇数，我们执行加法操作，否则执行除法操作。之后，我们需要执行 X - Y 次加法操作以得到 X。
     * </p>
     * 为什么这道题采用逆向思维更优？ 正向思维：在X<Y时要实现操作数最小，要将X逼近Y的1/2值或1/4值或1/8值或...再进行*2操作，
     * 难点在于要判断要逼近的是1/2值还是1/4值还是其他值，逻辑复杂 逆向思维：在Y>X时Y只管/2，到了Y<X时在+1逼近 说白了就是，
     * 正向思维采用的是先小跨度的-1操作，再大跨度的*2操作；逆向思维采用的是先大跨度的/2操作，再小跨度的-1操作 然而事实上往往是先大后小的解决问题思维在实现起来会比较简单
     *
     * @param x
     * @param y
     * @return
     */
    private int fun(int x, int y) {
        int result = 0;
        while (y > x) {
            // 可以确定的是，当y>x，有x*2然后再减所需要的步骤，一定大于y/2再加所需要的步骤
            result++;
            if (y % 2 == 0) {
                y /= 2;
            } else {
                y++;
            }
        }
        return result + x - y;
    }
}
